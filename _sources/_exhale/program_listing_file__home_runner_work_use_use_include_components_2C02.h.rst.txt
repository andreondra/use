
.. _program_listing_file__home_runner_work_use_use_include_components_2C02.h:

Program Listing for File 2C02.h
===============================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_use_use_include_components_2C02.h>` (``/home/runner/work/use/use/include/components/2C02.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   
   #ifndef USE_2C02_H
   #define USE_2C02_H
   
   #include <cstdint>
   #include <cstring>
   #include <vector>
   #include "Port.h"
   #include "Component.h"
   #include "Types.h"
   
   class R2C02 : public Component {
   
   protected:
   
       // ===========================================
       // PPU memory addresses
       // ===========================================
       constexpr static AddressRange ADDR_PATTERN_TABLES{0x0000, 0x1FFF};
       constexpr static AddressRange ADDR_NAMETABLES{0x2000, 0x2FFF};
       constexpr static AddressRange ADDR_PALETTE_RAM{0x3F00, 0x3FFF};
   
       // ===========================================
       // Sizes
       // ===========================================
       static const uint16_t OUTPUT_BITMAP_WIDTH = 256;
       static const uint16_t OUTPUT_BITMAP_HEIGHT = 240;
   
       static const uint16_t PATTERN_TABLE_TILE_ROW_COUNT = 16;
       static const uint16_t PATTERN_TABLE_TILE_COLUMN_COUNT = 16;
       static const uint16_t PATTERN_TABLE_PLANE_SIZE = 8;
   
       uint8_t m_dataBuffer = 0x00;
   
       struct internalRegisters_t{
   
           union{
   
               struct STR{
   
                   uint16_t coarseX : 5;
                   uint16_t coarseY : 5;
                   uint16_t nameX : 1;
                   uint16_t nameY : 1;
                   uint16_t fineY : 3;
                   uint16_t padding : 1;
               } bits;
               uint16_t data;
           } v,t;
   
           uint8_t x;  
           bool w;     
   
       } m_internalRegisters;
   
       struct{
   
           // 64 sprites for the frame.
           uint8_t primaryOAM[256];
           // 8 sprites for the current scanline.
           uint8_t secondaryOAM[32];
           // Attributes.
           uint8_t attrLatch[8];
           // X positions.
           uint8_t x[8];
   
           uint8_t shiftLo[8];
           uint8_t shiftHi[8];
           uint8_t allowShift[8];
   
           uint8_t secondarySpriteId;
   
           uint8_t feedY;
           uint16_t feedTileAddress;
           uint8_t feedIndex;
   
           void renderInit(){
   
               memset(secondaryOAM, 0xFF, 32);
   
               secondarySpriteId = 0;
               feedIndex = 0;
           }
   
           void shiftClear(){
   
               memset(x, 0, 8);
               memset(shiftHi, 0, 8);
               memset(shiftLo, 0, 8);
               memset(attrLatch, 0, 8);
               memset(allowShift, 0, 8);
           }
   
           void shift(){
   
               for(uint8_t i = 0; i < 8; i++)
                   if(allowShift[i]){
                       if((attrLatch[i] & 0x40) > 0){
   
                           shiftHi[i] >>= 1;
                           shiftLo[i] >>= 1;
                       } else {
   
                           shiftHi[i] <<= 1;
                           shiftLo[i] <<= 1;
                       }
                   }
           }
   
           void clear(){
   
               memset(primaryOAM, 0, 256);
               shiftClear();
               renderInit();
           }
       }m_spriteData;
   
       struct{
   
           uint8_t ntByte;
           uint8_t atByte;
           uint16_t tileData;
   
           uint16_t shiftTileLo;
           uint16_t shiftTileHi;
           uint16_t shiftAttrLo;
           uint16_t shiftAttrHi;
       } m_backgroundData;
   
       struct registers_t{
   
           union{
   
               struct{
                   uint8_t nameX : 1;              
                   uint8_t nameY : 1;              
                   uint8_t incMode : 1;            
                   uint8_t spriteAddress : 1;      
                   uint8_t backgroundAddress : 1;  
                   uint8_t spriteSize : 1;         
                   uint8_t masterSlave : 1;        
                   uint8_t nmi : 1;                
               } bits;
   
               uint8_t data;
           } ppuctrl;
   
           union{
   
               struct{
                   uint8_t grayscale : 1;          
                   uint8_t showBackgroundLeft : 1; 
                   uint8_t showSpritesLeft : 1;    
                   uint8_t showBackground : 1;     
                   uint8_t showSprites : 1;        
                   uint8_t eRed : 1;               
                   uint8_t eGreen : 1;             
                   uint8_t eBlue : 1;              
   
               } bits;
   
               uint8_t data;
           } ppumask;
   
           union{
   
               struct{
                   uint8_t padding : 5;        
                   uint8_t spriteOverflow : 1; 
                   uint8_t spriteZeroHit : 1;  
                   uint8_t vBlank : 1;         
               } bits;
   
               uint8_t data;
           } ppustatus;
   
           union{
   
               struct{
                   uint8_t byte : 2;
                   uint8_t index : 6;
               } bits;
   
               uint8_t data;
           } oamAddress;
   
       } m_registers;
   
       bool m_scanlineReady = false;
       bool m_frameReady = false;
   
       bool m_oddScan = false;
   
       bool m_settingsEnableForeground = true;
       bool m_settingsEnableBackground = true;
   
       bool m_blockNMI = false;
   
       const RGBPixel m_colors2C02[64] = {
   
               {84, 84, 84},
               {0, 30, 116},
               {8, 16, 144},
               {48, 0, 136},
               {68, 0, 100},
               {92, 0, 48},
               {84, 4, 0},
               {60, 24, 0},
               {32, 42, 0},
               {8, 58, 0},
               {0, 64, 0},
               {0, 60, 0},
               {0, 50, 60},
               {0, 0, 0},
               {0, 0, 0},
               {0, 0, 0},
               {152, 150, 152},
               {8, 76, 196},
               {48, 50, 236},
               {92, 30, 228},
               {136, 20, 176},
               {160, 20, 100},
               {152, 34, 32},
               {120, 60, 0},
               {84, 90, 0},
               {40, 114, 0},
               {8, 124, 0},
               {0, 118, 40},
               {0, 102, 120},
               {0, 0, 0},
               {0, 0, 0},
               {0, 0, 0},
               {236, 238, 236},
               {76, 154, 236},
               {120, 124, 236},
               {176, 98, 236},
               {228, 84, 236},
               {236, 88, 180},
               {236, 106, 100},
               {212, 136, 32},
               {160, 170, 0},
               {116, 196, 0},
               {76, 208, 32},
               {56, 204, 108},
               {56, 180, 204},
               {60, 60, 60},
               {0, 0, 0},
               {0, 0, 0},
               {236, 238, 236},
               {168, 204, 236},
               {188, 188, 236},
               {212, 178, 236},
               {236, 174, 236},
               {236, 174, 212},
               {236, 180, 176},
               {228, 196, 144},
               {204, 210, 120},
               {180, 222, 120},
               {168, 226, 144},
               {152, 226, 180},
               {160, 214, 228},
               {160, 162, 160},
               {0, 0, 0},
               {0, 0, 0}
       };
   
       //External PPU colors.
   
       // Current PPU rendering colors.
       const RGBPixel *m_colors = m_colors2C02;
   
       // ===============================================
       // Background rendering procedures.
       void verticalIncrement();
       void horizontalIncrement();
       void verticalTransfer();
       void horizontalTransfer();
       void fetchNT();
       void fetchAT();
       void fetchTileLo();
       void fetchTileHi();
       void feedShifters();
       void shiftShifters();
       // ===============================================
       // Foreground rendering procedures.
       void evaluateSprites();
       void fetchSprite(uint8_t offset);
       // ===============================================
       // Color palletes.
       uint8_t m_palettes[32];
       // ===============================================
       // Current rendering coordinates.
       int m_clock, m_scanline;
       // ===============================================
       // NES screen.
       std::vector<std::vector<RGBPixel>> m_screen{OUTPUT_BITMAP_HEIGHT, {OUTPUT_BITMAP_WIDTH, {0, 0, 0}}};
   
       // Internal PPU bus I/O.
       uint8_t ppuBusRead(uint16_t addr);
       void ppuBusWrite(uint16_t addr, uint8_t data);
       // ===============================================
   
       // ===========================================
       // Helpers
       // ===========================================
       RGBPixel getPixelColor(uint8_t paletteId, uint8_t pixel);
       RGBPixel getColorFromPalette(uint8_t bgFg, uint8_t paletteNumber, uint8_t pixelValue);
       RGBPixel applyPixelEffects(RGBPixel pixel) const;
       static uint8_t saturate(uint8_t x, uint8_t y);
       static uint8_t desaturate(uint8_t x, uint8_t y);
   
       // ===========================================
       // I/O
       // ===========================================
       // Connection to the PPU bus (controlled by the PPU).
       DataPort m_ppuBus;
       // Interrupt generator. Normally connected to the 6502's NMI pin.
       SignalPort m_INT;
   
   public:
   
       R2C02();
       ~R2C02() = default;
   
       // ===============================================
       // PPU control.
       void init();
   
       void clock();
   
       // ===============================================
       void OAMDMA(uint8_t addr, uint8_t data);
       // ===============================================
       // Output
       std::vector<RGBPixel> getPalette(uint8_t paletteId);
       uint8_t *getPaletteRAM();
       std::vector<std::vector<RGBPixel>> getPatternTable(uint8_t colorType, uint8_t paletteId, uint8_t index, bool applyEffects = false);
       std::vector<RGBPixel> getScreen();
       bool scanlineFinished() const;
       bool frameFinished() const;
   
       std::vector<EmulatorWindow> getGUIs() override;
   
   };
   
   #endif //USE_2C02_H
